一、模板概念：
模板是对具有相同特性的函数或类的再抽象；
是一种参数多态性工具，可以为逻辑相同而类型不同的程序提供代码共享机制；
模板并非实实在在的函数或类，仅仅是其描述，是参数化的函数或类。

二、模板分类：
函数模板/类模板

三、函数模板与模板函数：
提供了一种通用的函数行为，可以用多种不同的数据类型进行调用；
编译器会根据调用类型自动将它实例化为具体数据类型的函数代码；
也就是说，函数模板代表了一个函数家族；
函数模板中某些函数元素的数据类型是未确定的，将在使用时被参数化。

函数模板定义：
template <class T1, class T2, ...> 返回类型 函数名(参数列表)
{
	...
}
注意：
1、template语句与函数模板定义之间不允许有任何其他语句
2、函数模板可以有多个类型的参数，且可以是非类型参数，比如int
3、可以用typename替代class表示数据类型

函数模板的实例化：
	发生时机：模板实例化发生在调用模板函数时。当编译器遇到程序中对函数模板的
		调用时，它才会根据调用语句中实参的具体类型，确定模板参数的数据类型，
		并用此类型替换函数模板中的模板参数，生成能够处理该类型的函数代码，即
		”模板函数“
	实例化次数：当发生多次相同类型的参数调用时，只在第一次进行实例化。假设有
		下面的函数调用：
		int x = min(2,3);
		int y = min(3,9);
		编译器只在首次调用时生成模板函数。
	实例化的方式：
		隐式实例化：编译器能够判断模板参数类型时，自动实例化函数模板为模板函数;
			template <typename T> T max(T, T);
			...
			int i = max(2,3);
			float f = max(1.0, 2.0);
			char ch = max('a', 'A');
		显式实例化：编译器不能判断模板参数类型或常量值，需要使用特定数据类型实例化：
			template <class T> T max(T, T);
			...
			int i = max(1, '2'); // error，data type can't be deducd
			int i = max<int>(1, '2');

函数模板的特化：
	特化原因：有些情况下，模板描述的通用算法不适合特定场合，例如：
		char* cp = max("ABCD", "1234");
		函数模板实例化为：char* max(char* a, char* b){return a > b ? a: b;}
		明显，上述实例化结果无法实现字符串比较。
	特殊：针对模板不能处理的特殊数据类型，编写与模板同名的特殊函数进行逻辑专门定义；
		特化定义形式：
			template <> 返回类型 函数名<特化的数据类型>(参数表){......}
			其中，template <>是模板特化的关键字，函数名后的<>是说明须特化的数据类型。

说明：
	当程序中同时存在模板和其特化时，特化将优先被调用；
	除了特化和函数模板外，可以有同名的普通函数；
	C++会对普通函数的调用实参进行隐式的数据转换，但不会对模板函数及特化进行类型转换；
	调用顺序：完全匹配的非模板函数->完全匹配的模板函数->类型相容的非模板函数。
	
四、类模板
定义：用来设计结构和成员函数完全相同，但所处理的数据类型不同的通用类：
	class doubleStack{
	private:
		double data[size];
	};
	class charStack{
	private:
		char data[size];
	};
	除了数据类型不同以外，操作完全相同，就可以用类模板实现。
	
类模板的声明：
	template <class T1, class T2, ...>
	class 类名{
		...
	};

非类型参数：
	非类型参数是指某种具体的数据类型，在调用模板时只能为其提供相应类型的常数值；
	通常可以是整形、枚举、对象或者函数的引用，以及对象、函数或类成员的指针；
	不允许使用浮点、双精、类对象或者void作为非类型参数；
		template <class T1, class T2, int T3>
		在实例化时，必须为T1、T2提供一种数据类型，并将T3指定为一个整常数(如10)。
	
类模板成员函数的定义：
	方法1：类模板外定义：
		template <模板参数列表> 返回值类型 类模板名<模板参数名表>::成员函数名(参数列表){...}
	方法2：成员函数定义：
		与常规成员函数定义类似，模板参数列表中引入类型标识符作为数据类型使用，模板参数列表
		中引入的普通数据类型常量作为常量使用

类模板特化：
	 一种是特化整个类模板，一种是特化个别成员函数：
	 template <> 返回类型 类模板名<特化的数据类型>::特化成员函数名(参数表){
		...
	 }
	 template <> void Array<char *>::sort(){
		...
	 }
	
	


















































